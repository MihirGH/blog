{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/leetcode-one-dimensional-dp-problems",
    "result": {"data":{"post":{"slug":"/leetcode-one-dimensional-dp-problems","title":"Leetcode One Dimensional DP problems","date":"18.05.2022","tags":[{"name":"DynamicProgramming","slug":"dynamic-programming"},{"name":"Algorithms","slug":"algorithms"},{"name":"Blind75","slug":"blind-75"},{"name":"LeetCode","slug":"leet-code"}],"description":"A blog meant to serve as breadcrumbs for my futureself consisting of thoughts, gotchas and the final solutions when going through the LeetCode problems in the Blind75 list around 1D DP.","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Leetcode One Dimensional DP problems\",\n  \"date\": \"2022-05-18T00:00:00.000Z\",\n  \"updatedOn\": \"2022-05-18T00:00:00.000Z\",\n  \"description\": \"A blog meant to serve as breadcrumbs for my futureself consisting of thoughts, gotchas and the final solutions when going through the LeetCode problems in the Blind75 list around 1D DP.\",\n  \"tags\": [\"DynamicProgramming\", \"Algorithms\", \"Blind75\", \"LeetCode\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/maximum-subarray/\"\n  }, \"Maximum Subarray\")), mdx(\"h4\", null, \"Problem Statement:\"), mdx(\"p\", null, \"Given an integer array \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums\"), \", find the contiguous subarray (containing at least one number) which has the largest sum and return \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"its sum\"), \".\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"subarray\"), \" is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"contiguous\"), \" part of an array.\"), mdx(\"h4\", null, \"Solution:\"), mdx(\"h5\", null, \"Kadane's Algorithm:\"), mdx(\"p\", null, \"Let's say we define \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum(i)\"), \" as the maximum sub-array sum for all sub-arrays ending at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \".\\nThis means that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum(i) = Math.max(subArraySum(0, i), subArraySum(1, i), ..., subArraySum(i, i))\"), \" where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"subArraySum(l, r)\"), \" is the sum of the sub-array starting at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"l\"), \" and ending at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"r\"), \".\"), mdx(\"p\", null, \"Similarly, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum(i + 1) = Math.max(subArraySum(0, i + 1), subArraySum(1, i + 1), ..., subArraySum(i + 1, i + 1))\"), \".\\nBut since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"subArraySum(0, i + 1) = subArraySum(0, i) + nums[i + 1]\"), \" we can write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum(i + 1)\"), \" as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.max(subArraySum(0, i) + nums[i + 1], subArraySum(1, i) + nums[i + 1], ..., nums[i + 1])\"), \".\"), mdx(\"p\", null, \"Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.max(a + y, b + y, c + y) = Math.max(a, b, c) + y\"), \" we can write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum(i + 1)\"), \" as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.max(Math.max(subArraySum(0, i), ..., subArraySum(i, i)) + nums[i + 1], 0 + nums[i + 1])\"), \".\\nAnd since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.max(subArraySum(0, i), ..., subArraySum(i, i)) = maxSum(i)\"), \" we have our final recurrence relation as:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum(i + 1) = Math.max(maxSum(i) + nums[i + 1], nums[i + 1])\"), \".\"), mdx(\"p\", null, \"We can store this in a 1D array. Since we don't know at which index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"k\"), \" our sub-array with maximum sum ends,\\nwe need to loop through all the indices and take max of all the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum(i)\"), \" for all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0 <= i < nums.length\")), mdx(\"p\", null, \"The above solution has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(N)\"), \" time and space complexity. But we can cleverly get rid of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(N)\"), \" space and make its space complexity \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(1)\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Memory Optimiszation\"), \":\"), mdx(\"p\", null, \"Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum(i + 1)\"), \" only depends on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum(i)\"), \" we can keep a variable called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prevMaxSum\"), \" and have a global \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum\"), \" variable which will eventually store our answer.\\nWe initialise \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prevMaxSum\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[0]\"), \". Then we loop through all the elements from index 1 and calculate the currentSum as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prevSum + nums[i]\"), \".\\nWe set maxSum as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.max(maxSum, currentSum)\"), \" and later assign \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prevMaxSum\"), \" as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"currentSum\"), \".\"), mdx(\"p\", null, \"The code for the above approach can be found \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://leetcode.com/submissions/detail/700080102/\"\n  }, \"here\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A greedy approach that leads to the same algorithm\"), \":\"), mdx(\"p\", null, \"We want to find all the sub-arrays with positive sum and then find the maximum out of those sub-arrays.\\nSo, we keep a variable called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sumSoFar\"), \" and initialise it with nums\", \"[0]\", \". When we are at the ith element, we check if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sumSoFar < 0\"), \".\\nIf the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sumSoFar\"), \" is less than zero then there's no point in continuing that sub-array and we should start a new max sub-array candidate starting at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \".\\nAfter updating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sumSoFar\"), \" we check if the updated value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sumSoFar\"), \" is the maximum we have seen so far or not and update our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxSum\"), \" variable accordingly to update our answer.\"), mdx(\"p\", null, \"This way, we will always have either:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"positive values of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sumSoFar\"), \" - corresponding to the sub-arrays with positive sum.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"or the least negative value out of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"nums\"), \" array - if all elements of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"nums\"), \" array were negative.\")), mdx(\"hr\", null), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/jump-game/\"\n  }, \"Jump Game\")), mdx(\"h4\", null, \"Problem Statement:\"), mdx(\"p\", null, \"You are given an integer array \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums\"), \". You are initially positioned at the array's \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"first index\"), \", and each element in the array represents your maximum jump length at that position.\"), mdx(\"p\", null, \"Return \", mdx(\"em\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"true\"), \" if you can reach the last index, or \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"false\"), \" otherwise\"), \".\"), mdx(\"h4\", null, \"Solution:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Recursive Solution:\")), mdx(\"p\", null, \"We can reach the last index from an index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" if:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we can reach the last index from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"(i + 1)\"), \"th index or\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we can reach the last index from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"(i + 2)\"), \"th index or\\n...\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we can reach the last index from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"(i + nums[i])\"), \"th index\")), mdx(\"p\", null, \"And we can get a nice recurrence relation as:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"canReachFrom(i) = canReachFrom(i + 1) || ... || canReachFrom(i + nums[i])\\n\")), mdx(\"p\", null, \"We can also see that while computing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"canReachFrom(i + 1)\"), \" we might also end up computing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"canReachFrom(i + 2)\"), \" which might also be needed for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"canReachFrom(i)\"), \".\\nSo, we can also memoize the answers for each index so we don't end up doing duplicate work.\"), mdx(\"p\", null, \"Recursively we can write the code as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const indexVsReachableMap = new Map<number, boolean>();\\n\\nfunction canReachFrom(currentIndex: number, nums: number[]): boolean {\\n  if (indexVsReachableMap.has(currentIndex)) {\\n    return indexVsReachableMap.get(currentIndex);\\n  }\\n\\n  if (currentIndex >= nums.length - 1) return true;\\n\\n  let answer = false;\\n  for (let offset = 1; offset <= nums[currentIndex]; offset++) {\\n    const nextIndex = currentIndex + offset;\\n    const isReachable = canReachFrom(nextIndex, nums);\\n    if (isReachable) {\\n      answer = true;\\n      break;\\n    }\\n  }\\n\\n  indexVsReachableMap.set(currentIndex, answer);\\n\\n  return answer;\\n}\\n\")), mdx(\"p\", null, \"The happy case will be if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i] >= (n - 1 - i)\"), \" for every \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0 <= i < n - 1\"), \". In this case, we will end up having only one branch of depth \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \".\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"canReachFrom(0)\"), \" will call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"canReachFrom(1)\"), \" which will call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"canReachFrom(2)\"), \" and it will go on till \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"canReachFrom(n - 2)\"), \" and we would have returned true since everything was reachable.\"), mdx(\"p\", null, \"The worst case scenario will occurr when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"canReachFrom(n - 2)\"), \" is false and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i] === (n - 2) - i\"), \" meaning it is possible to reach \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(n - 2)\"), \"th index from every idnex.\\nIn that case, from the bottom of the recursion callstack, we will have:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(n - 3)\"), \" which checks for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(n - 2)\"), \" and returns false\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(n - 4)\"), \" which checks for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(n - 3)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(n - 2)\"), \" and returns false.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(n - 5)\"), \" which checks for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(n - 4)\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(n - 3)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(n - 2)\"), \" and returns false.\\n...\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(0)\"), \" which checks for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(1)\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(2)\"), \", ..., \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"canReachFrom(n - 2)\"), \" and returns false\")), mdx(\"p\", null, \"In the above case since we are going through all the elements at most \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" times and hence the time complexity is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n ^ 2)\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Iterative Solution:\")), mdx(\"p\", null, \"Let's say we tried to write an iterative solution for the above recursive solution.\\nWe will keep an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isReachableFrom\"), \" array where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isReachableFrom[i]\"), \" indicates if it is possible to reach the last index from index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"isReachableFrom[i] = isReachableFrom[i + 1] || ... || isReachableFrom[i + nums[i]]\\n\")), mdx(\"p\", null, \"From above recurrence relation, we know that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isReachableFrom[i]\"), \" depends on the values of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isReachableFrom[j]\"), \" where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i < j <= i + nums[i]\"), \".\\nHence, we will start filling this array backwards.\"), mdx(\"p\", null, \"The code for the above approach can be found \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://leetcode.com/submissions/detail/701582297/\"\n  }, \"here\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Greedy Solution:\")), mdx(\"p\", null, \"Since we are only interested in finding out if we can reach the last index or not, we can use a greedy solution.\\nWe start off with keeping a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach\"), \" variable which any given index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" during the iteration, indicates the maximum reachable index from all of the indices in the range \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[0, i]\"), \".\\nSo at the beginning we initialise it with 0 since the reach is zero before starting our iteration.\\nThen we loop through all indices from 0 to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(n - 2)\"), \" and if a particular index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" is reachable i.e., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i <= maxReach\"), \", we update the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach\"), \" by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.max(maxReach, i + nums[i])\"), \".\\nAt last, we return true if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach >= n - 1\"), \" else false.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Proof of correctness:\")), mdx(\"p\", null, \"We prove the correctness by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"invariant\"), \".\"), mdx(\"p\", null, \"Before entering the loop, we have set our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach\"), \" variable to 0.\\nIf there is only one element in the array, the last index is 0 and it is reachable. Setting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach\"), \" to 0 satisfies that edge case.\"), mdx(\"p\", null, \"Inside the loop, for given index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach\"), \" indicates the largest reachable index from all the indices in the range \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[0, i - 1]\"), \".\\nIf the current index i is not reachable from the previous \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[0, (i - 1)]\"), \" indices then \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i > maxReach\"), \" and we cannot reach till the last index.\\nSo we break the loop and return false. Otherwise if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i <= maxReach\"), \" then our new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach\"), \" is max of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i + nums[i]\"), \" or the previous \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach\"), \".\"), mdx(\"p\", null, \"If the loop terminates successfully then it means that we completed the last iteration for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(n - 2)\"), \"th index successfully and we know for sure that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n - 2\"), \" is not greater than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach\"), \".\\nHence we know for sure that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach >= n - 2\"), \" and we eventually just need to check if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxReach >= n - 1\"), \" and return true if that's the case.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Maximum Subarray Problem Statement: Given an integer array  nums , find the contiguous subarray (containing at least one number) which has…","timeToRead":3,"banner":null}},"pageContext":{"slug":"/leetcode-one-dimensional-dp-problems","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}