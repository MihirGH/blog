{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/blind-75",
    "result": {"data":{"post":{"slug":"/blind-75","title":"Blind 75","date":"06.04.2022","tags":[{"name":"Blind75","slug":"blind-75"},{"name":"LeetCode","slug":"leet-code"}],"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Blind 75\",\n  \"date\": \"2022-04-06T00:00:00.000Z\",\n  \"updatedOn\": \"2022-08-04T00:00:00.000Z\",\n  \"tags\": [\"Blind75\", \"LeetCode\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/two-sum/\"\n  }, \"Two Sum\")), mdx(\"h4\", null, \"Problem Statement:\"), mdx(\"p\", null, \"Given an array of integers \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums\"), \" and an integer \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"target\"), \", return indices of the two numbers such that they add up to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"target\"), \".\"), mdx(\"h4\", null, \"Initial Thoughts:\"), mdx(\"h5\", null, \"Brute force search in \", mdx(\"inlineCode\", {\n    parentName: \"h5\"\n  }, \"O(n^2)\"), \":\"), mdx(\"p\", null, \"Loop through each element \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and find if there is another value that equals to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"target\"), \" - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\")), mdx(\"h5\", null, \"Using Map:\"), mdx(\"p\", null, \"For a more efficient way to check if the complement exists in the array - we can maintain a Map.\\nFor each element \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i]\"), \", we will store \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i]\"), \" as key.\\nThis will reduce the time down to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n)\"), \" but it will also have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n)\"), \" space complexity.\"), mdx(\"p\", null, \"We can do better than going through the array twice.\\nWhile we are constructing the Map we can check if its complement has already been inserted or not.\"), mdx(\"h6\", null, \"Solution:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function twoSum(nums: number[], target: number): number[] {\\n  const map = new Map<number, number>(nums.map((num, index) => [num, index]));\\n  let answer: number[] = [];\\n\\n  nums.forEach((num, index) => {\\n    const complementNumber = target - num;\\n    const complementIndex = map.get(complementNumber);\\n    if (typeof complementIndex === \\\"undefined\\\") return;\\n    if (complementIndex === index) return;\\n\\n    answer = [index, complementIndex];\\n  });\\n\\n  return answer;\\n}\\n\")), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/two-sum/\"\n  }, \"Longest substring without repeating characters\")), mdx(\"h4\", null, \"Problem Statement:\"), mdx(\"p\", null, \"Given a string \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s\"), \", find the length of the longest substring without repeating characters.\"), mdx(\"h4\", null, \"Initial Thoughts:\"), mdx(\"h5\", null, \"Brute force:\"), mdx(\"p\", null, \"Fix an initial starting index say \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \".\\nNow search for all the substrings starting at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" and ending at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"j\"), \" where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i <= j < s.length\"), \"\\nNow in this substring find if there are any repeating characters - if not check with the best answer so far and if it beats the best answer then consider this as the new best answer.\\nThe time complexity depends on how we are finding if there are any repeating characters in a string.\"), mdx(\"p\", null, \"So the time complexity will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n ^ 2 * (cost of finding repeating characters))\")), mdx(\"h5\", null, \"Two pointer approach:\"), mdx(\"p\", null, \"Keep a left pointer which starts from index 0. Initialise the right pointer also at index 0.\"), mdx(\"p\", null, \"If the substring from left to right does not have repeating characters then we can increment the right pointer while the constraint is met.\\nIf the substring has repeating characters then we have two choices:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Either we keep incrementing the right pointer - but that doesn't make any sense because the string has repeated characters.\\nAny more addition in the string will only make it contain repeated characters\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Or we can increment the left pointer and hope to drop the repeating characters\")), mdx(\"p\", null, \"Since in this approach, all the elements will be traversed at most twice - once by each left and right pointer.\\nSo the time complexity will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n * (cost of finding repeating characters))\")), mdx(\"p\", null, \"I wouldn't have been able to solve this using two-pointer approach had I not watched the video from the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=eS6PZLjoaq8\"\n  }, \"Back to Back SWE\"), \".\"), mdx(\"p\", null, \"But the main problem still remains to be solved: How do I find if a string has repeating characters or not?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function hasRepeatingCharacters(s: string): boolean {\\n  const seenCharacters = new Set([...s]);\\n  return seenCharacters.size < s.length;\\n}\\n\\nfunction lengthOfLongestSubstring(s: string): number {\\n  let leftPointer = 0;\\n  let rightPointer = 1;\\n  let answer = 0;\\n\\n  while (rightPointer <= s.length) {\\n    const substringToCheck = s.substring(leftPointer, rightPointer);\\n    if (hasRepeatingCharacters(substringToCheck)) {\\n      leftPointer += 1;\\n      continue;\\n    }\\n    answer = Math.max(answer, substringToCheck.length);\\n    rightPointer += 1;\\n  }\\n\\n  return answer;\\n}\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/two-sum/\"\n  }, \"Longest palindromic substring\")), mdx(\"p\", null, \"I was lazy to write all my thoughts on this day since the problem was a bit difficult and I couldn't think about anything other than a bruteforce solution\"), mdx(\"hr\", null), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/container-with-most-water/\"\n  }, \"Container With Most Water\")), mdx(\"h4\", null, \"Problem Statement:\"), mdx(\"p\", null, \"You are given an integer array height of length \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \". There are n vertical lines drawn such that the two endpoints of the ith line are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, 0)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, height[i])\"), \".\"), mdx(\"p\", null, \"Find two lines that together with the x-axis form a container, such that the container contains the most water.\"), mdx(\"p\", null, \"Return the maximum amount of water a container can store.\"), mdx(\"h4\", null, \"Initial Thoughts:\"), mdx(\"h5\", null, \"Brute force:\"), mdx(\"p\", null, \"Pick all the possible pairs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"j\"), \".\\nThe answer is not dependent on how tall or short beams lies between them but only on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"heights[i]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"heights[j]\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"let answer = 0;\\nfor (let i = 0; i < n; i++) {\\n  for (let j = i + 1; j < n; j++) {\\n    const area = (j - i) * Math.min(heights[i], heights[j]);\\n    answer = Math.max(area, answer);\\n  }\\n}\\nreturn answer;\\n\")), mdx(\"h5\", null, \"Optimized Approach:\"), mdx(\"p\", null, \"I could come up with this constraint but it wasn't that useful:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We want to maximise the product of distance between two lines and the difference of heights between two lines\")), mdx(\"p\", null, \"Had to look at hints but still wasn't very clear how I could optimise the brute force solution, Hint:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Start with the maximum width container and go to a shorter width container if there is a vertical line longer than the current containers shorter line.\\nThis way we are compromising on the width but we are looking forward to a longer length container.\")), mdx(\"p\", null, \"After looking at the hint I thought:\"), mdx(\"p\", null, \"For any given range \", \"[L, R]\", \", we have two choices: \", \"[L + 1, R]\", \" and \", \"[L, R - 1]\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We should move to L + 1 if heights\", \"[L]\", \" < maxHeights(L + 1, R)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We should move to R - 1 if heights\", \"[R]\", \" < maxHeights(L, R - 1)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If heights\", \"[L]\", \" === heights\", \"[R]\", \" - we can move to whoever has maximum among maxHeights(L + 1, R), maxHeights(L, R - 1)\")), mdx(\"p\", null, \"And then I got stuck on how to construct the said \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxHeights\"), \" function\"), mdx(\"h4\", null, \"Solution:\"), mdx(\"p\", null, \"Start the left pointer at the beginning and the right pointer at the end\"), mdx(\"p\", null, \"If at any point \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"heights[l] <= heights[r]\"), \" then we move the left pointer by 1 in the right direction. Otherwise we move the right pointer by 1 in the left direction.\"), mdx(\"h5\", null, \"Proof of correctness:\"), mdx(\"p\", null, \"Suppose our left pointer is at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" and our right pointer is at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"j\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(i, j)\"), \" is the current answer.\"), mdx(\"p\", null, \"Say \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"heights[i] <= heights[j]\"), \" and we move to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(i + 1, j)\"), \"\\nIn this case, we are omitting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(i, j - 1)\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(i, j - 2)\"), \" and so on till \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(i, i + 1)\"), \".\"), mdx(\"p\", null, \"But for all such right pointers we have omitted, the minimum height would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"heights[i]\"), \" or even lesser than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"heights[i]\"), \".\\nAlso, the distance would be at least one less than what was between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"j\"), \" and hence we are making our area lesser if we had decreased our right pointer in this case.\\nHence, there is no way that the omitted states will have better answer compared to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(i, j)\"), \".\"), mdx(\"p\", null, \"Same can be said about the other case: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"heights[j] < heights[i]\"), \" and we move to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(i, j - 1)\"), \"\\nIn this case we are omitting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(i + 1, j)\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(i + 2, j)\"), \" and so on till \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(j - 1, j)\"), \".\"), mdx(\"p\", null, \"But for all such left pointers we have omitted, the minimum height would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"heights[j]\"), \" or even lesser than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"heights[j]\"), \".\\nAlso, the distance would be at least one less than what was between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"j\"), \" and hence we are only making our area lesser if we had incremented our left pointer in this case.\\nHence, there is no way that the omitted states will have better answer compared to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"S(i, j)\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function maxArea(heights: number[]): number {\\n  let answer = 0;\\n  let leftPointer = 0;\\n  let rightPointer = heights.length - 1;\\n\\n  while (leftPointer < rightPointer) {\\n    const distance = rightPointer - leftPointer;\\n    answer = Math.max(\\n      answer,\\n      distance * Math.min(heights[leftPointer], heights[rightPointer])\\n    );\\n    if (heights[leftPointer] <= heights[rightPointer]) {\\n      leftPointer += 1;\\n    } else {\\n      rightPointer -= 1;\\n    }\\n  }\\n\\n  return answer;\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"You have two heights \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h[l]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h[r]\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h[l]\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h[r]\"), \", then we know we have two choices, we want to move one of them. If we move the larger one, we cannot increase the height for the simple reason that we are always limited by the shortest, and we would be decreasing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"j - i\"), \", the width as well.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"To clarify: let's say we kept the shortest forever, what would happen? Well, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"j - i\"), \" would decrease, and either we come across a taller block, which doesn't matter because our shorter one we kept only mattered, or we find a shorter one, in which case that one matters.\\nEither way we end up with a smaller area, so we must move the shorter one because moving the larger one cannot give an increase in area.\")), mdx(\"hr\", null), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/trapping-rain-water/\"\n  }, \"Trapping Rain Water\")), mdx(\"h4\", null, \"Problem Statement:\"), mdx(\"p\", null, \"Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\"), mdx(\"h4\", null, \"Initial Thoughts:\"), mdx(\"h5\", null, \"Pointer based approach - Failing for a particular edge case :'(\"), mdx(\"p\", null, \"We need to first find the index of the \\\"bar\\\" which has non zero height, say \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \".\\nSimilarly, we need to find the index of the last bar which has non zero height, say \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \".\\nWe need to do this because we can't trap the water before these non-zero heighted bars.\"), mdx(\"p\", null, \"We will initialise our left pointer L at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and our right pointer R at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x + 1\"), \".\\nNow, we will keep increasing our right pointer till we find the first bar which has height greater than height\", \"[L]\", \".\\nThe way we have constructed our pointers, right now R is the first index in the \", \"[L, R]\", \" range for which height\", \"[L]\", \" < height\", \"[R]\", \"\\nSo, we can go ahead and assume a cube from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"L + 1\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"R - 1\"), \" with length of ((R - 1) - (L + 1) + 1) = (R - L - 1) and height of height\", \"[L]\", \" and width 1.\\nThis is the raw volume assuming that in the range \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"L + 1\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"R - 1\"), \" we have zero heighted bars in between.\\nWe need to compensate for those bars and we will do that by looping from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"L + 1\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"R\"), \" excluding R and subtracting height of all the bars in between.\\nThis will give us the water that can be trapped in the range \", \"[L, R]\", \".\"), mdx(\"p\", null, \"As soon as we have added the amount in the answer, we will set our left pointer to R and right pointer to R + 1 and keep searching for this till our right pointer is less than or equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \".\"), mdx(\"p\", null, \"But there's an edge case in this approach.\\nThere can be a case where our R has reached \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \" but the left pointer \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"L\"), \" is still stuck at the maximum value somewhere.\\nWe need to count the volume in between if water can be trapped in between.\\nThe water can only be trapped in this last range if there exists a minima in \", \"[L, R]\", \" otherwise if it is decreasing then no water can be trapped in between.\"), mdx(\"p\", null, \"Sadly, this is the part where I got stuck and couldn't think of any way to implement this.\"), mdx(\"h4\", null, \"Final Solution:\"), mdx(\"p\", null, \"I am yet to go through the solution so hopefully I will update it later hopefully!\"), mdx(\"hr\", null), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/3sum/\"\n  }, \"3Sum\")), mdx(\"h4\", null, \"Problem Statement:\"), mdx(\"p\", null, \"Given an integer array nums, return all the triplets \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[nums[i], nums[j], nums[k]]\"), \" such that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i != j\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i != k\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"j != k\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i] + nums[j] + nums[k] == 0\"), \".\"), mdx(\"h4\", null, \"Initial Thoughts:\"), mdx(\"h5\", null, \"Pointer based approach:\"), mdx(\"p\", null, \"Since we only need to find the triplets and the order doesn't matter, we can sort our array.\\nAfter sorting the array, we can loop from index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i = 0\"), \" till \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i + 2 < nums.length\"), \" and our task boils down to finding two numbers in the remaining sorted array whose sum add upto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-nums[i]\"), \".\"), mdx(\"p\", null, \"This sub-problem can be solved using two pointers where we initialise our left pointer L as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i + 1\"), \" and the right pointer R as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums.length - 1\"), \".\\nIf \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sortedNums[L] + sortedNums[R] > -sortedNums[i]\"), \" then that means we have to lower our right pointer because increasing L pointer in this case will only make the sum go high.\\nIf \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sortedNums[L] + sortedNums[R] < -sortedNums[i]\"), \" then that means we have to increase our left pointer because decreasing R pointer in this case will only make the sum go down.\\nAnd finally if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sortedNums[L] + sortedNums[R] === sortedNums[i]\"), \" then we have found the triplet where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i != L != R\"), \" and their sum is 0.\"), mdx(\"p\", null, \"But we still need to get rid of the duplicate triplets. For example, if the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums\"), \" array is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[1, -1, -1, 0]\"), \" then our above algorithm will report two triplets \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[[-1, 0, 1], [-1, 0, 1]]\"), \".\\nThis is happening because there are two distinct indices for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-1\"), \" which can be paired up with 0 and 1.\"), mdx(\"p\", null, \"So, to remove the duplicate triplets, I came up with a very naive solution:\\nI kept track of all pairs seen for a particular \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sortedNums[i]\"), \" if a triplet was found.\\nAnd if there existed pairs corresponding to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sortedNums[i]\"), \" I checked if any of the pair's first number was \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sortedNums[leftPointer]\"), \"\\nIf yes then \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[sortedNums[i], sortedNums[leftPointer], sortedNums[rightPointer]]\"), \" is already \\\"seen\\\" and has already been added to the answer and we can ignore this.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function threeSum(nums: number[]): number[][] {\\n  const answer: number[][] = [];\\n  const sortedNums = [...nums].sort((a, b) => a - b);\\n  const seenPairs = new Map<number, number[][]>();\\n\\n  for (let i = 0; i < sortedNums.length; i++) {\\n    let leftPointer = i + 1;\\n    let rightPointer = sortedNums.length - 1;\\n    const firstElement = sortedNums[i];\\n    let remainingSum = -firstElement;\\n\\n    while (leftPointer < rightPointer) {\\n      if (sortedNums[leftPointer] + sortedNums[rightPointer] === remainingSum) {\\n        const pairs = seenPairs.get(firstElement) || [];\\n        const pairWithLeftPointerExists = pairs.length\\n          ? pairs.some((pair) => pair[0] === sortedNums[leftPointer])\\n          : false;\\n\\n        if (!pairWithLeftPointerExists) {\\n          seenPairs.set(firstElement, [\\n            ...pairs,\\n            [sortedNums[leftPointer], sortedNums[rightPointer]],\\n          ]);\\n          answer.push([\\n            sortedNums[i],\\n            sortedNums[leftPointer],\\n            sortedNums[rightPointer],\\n          ]);\\n        }\\n\\n        leftPointer += 1;\\n        rightPointer -= 1;\\n        continue;\\n      }\\n      if (sortedNums[leftPointer] + sortedNums[rightPointer] > remainingSum) {\\n        rightPointer -= 1;\\n      } else {\\n        leftPointer += 1;\\n      }\\n    }\\n  }\\n\\n  return answer;\\n}\\n\")), mdx(\"p\", null, \"This solution is not memory efficient and may add extra overhead too when we are comparing it will all the \\\"seen\\\" triplets but it works.\"), mdx(\"h4\", null, \"Final Solution:\"), mdx(\"p\", null, \"An important thing to note here is that the triplet can only be repeated if we have multiple entries for either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i]\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[leftPointer]\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[rightPointer]\"), \" or all of the three. So, we can do a little bit better by:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Moving \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"i\"), \" to the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"last occurrence\"), \" for that particular number.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Once found the answer:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Keep increasing L so that we skip all multiple entries for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sortedNums[L]\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Keep decreasing R so that we skip all multiple entries for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sortedNums[R]\"), \".\\nand resume the search in now updated \", \"[L, R]\", \" range.\")))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function threeSum(nums: number[]): number[][] {\\n  const answer: number[][] = [];\\n  const sortedNums = [...nums].sort((a, b) => a - b);\\n\\n  for (let i = 0; i + 2 < sortedNums.length; i++) {\\n    // Skip same result\\n    if (i > 0 && sortedNums[i] === sortedNums[i - 1]) continue;\\n\\n    let leftPointer = i + 1;\\n    let rightPointer = sortedNums.length - 1;\\n    const firstElement = sortedNums[i];\\n    let remainingSum = -firstElement;\\n\\n    while (leftPointer < rightPointer) {\\n      if (sortedNums[leftPointer] + sortedNums[rightPointer] === remainingSum) {\\n        answer.push([\\n          sortedNums[i],\\n          sortedNums[leftPointer],\\n          sortedNums[rightPointer],\\n        ]);\\n\\n        leftPointer += 1;\\n        rightPointer -= 1;\\n\\n        // Skip same result\\n        while (\\n          leftPointer < rightPointer &&\\n          sortedNums[rightPointer] === sortedNums[rightPointer + 1]\\n        )\\n          rightPointer -= 1;\\n        while (\\n          leftPointer < rightPointer &&\\n          sortedNums[leftPointer] === sortedNums[leftPointer - 1]\\n        )\\n          leftPointer += 1;\\n\\n        continue;\\n      }\\n      if (sortedNums[leftPointer] + sortedNums[rightPointer] > remainingSum) {\\n        rightPointer -= 1;\\n      } else {\\n        leftPointer += 1;\\n      }\\n    }\\n  }\\n\\n  return answer;\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Two Sum Problem Statement: Given an array of integers  nums  and an integer  target , return indices of the two numbers such that they add…","timeToRead":7,"banner":null}},"pageContext":{"slug":"/blind-75","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}