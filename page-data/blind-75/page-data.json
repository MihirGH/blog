{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/blind-75",
    "result": {"data":{"post":{"slug":"/blind-75","title":"Blind 75","date":"06.04.2022","tags":[{"name":"Blind75","slug":"blind-75"},{"name":"LeetCode","slug":"leet-code"}],"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Blind 75\",\n  \"date\": \"2022-04-06T00:00:00.000Z\",\n  \"tags\": [\"Blind75\", \"LeetCode\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/two-sum/\"\n  }, \"Two Sum\")), mdx(\"h4\", null, \"Problem Statement:\"), mdx(\"p\", null, \"Given an array of integers \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums\"), \" and an integer \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"target\"), \", return indices of the two numbers such that they add up to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"target\"), \".\"), mdx(\"h4\", null, \"Initial Thoughts:\"), mdx(\"h5\", null, \"Brute force search in \", mdx(\"inlineCode\", {\n    parentName: \"h5\"\n  }, \"O(n^2)\"), \":\"), mdx(\"p\", null, \"Loop through each element \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and find if there is another value that equals to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"target\"), \" - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\")), mdx(\"h5\", null, \"Using Map:\"), mdx(\"p\", null, \"For a more efficient way to check if the complement exists in the array - we can maintain a Map.\\nFor each element \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i]\"), \", we will store \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i]\"), \" as key.\\nThis will reduce the time down to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n)\"), \" but it will also have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n)\"), \" space complexity.\"), mdx(\"p\", null, \"We can do better than going through the array twice.\\nWhile we are constructing the Map we can check if its complement has already been inserted or not.\"), mdx(\"h6\", null, \"Solution:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function twoSum(nums: number[], target: number): number[] {\\n  const map = new Map<number, number>(nums.map((num, index) => [num, index]));\\n  let answer: number[] = [];\\n\\n  nums.forEach((num, index) => {\\n    const complementNumber = target - num;\\n    const complementIndex = map.get(complementNumber);\\n    if (typeof complementIndex === \\\"undefined\\\") return;\\n    if (complementIndex === index) return;\\n\\n    answer = [index, complementIndex];\\n  });\\n\\n  return answer;\\n}\\n\")), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/two-sum/\"\n  }, \"Longest substring without repeating characters\")), mdx(\"h4\", null, \"Problem Statement:\"), mdx(\"p\", null, \"Given a string \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s\"), \", find the length of the longest substring without repeating characters.\"), mdx(\"h4\", null, \"Initial Thoughts:\"), mdx(\"h5\", null, \"Brute force:\"), mdx(\"p\", null, \"Fix an initial starting index say \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \".\\nNow search for all the substrings starting at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" and ending at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"j\"), \" where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i <= j < s.length\"), \"\\nNow in this substring find if there are any repeating characters - if not check with the best answer so far and if it beats the best answer then consider this as the new best answer.\\nThe time complexity depends on how we are finding if there are any repeating characters in a string.\"), mdx(\"p\", null, \"So the time complexity will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n ^ 2 * (cost of finding repeating characters))\")), mdx(\"h5\", null, \"Two pointer approach:\"), mdx(\"p\", null, \"Keep a left pointer which starts from index 0. Initialise the right pointer also at index 0.\"), mdx(\"p\", null, \"If the substring from left to right does not have repeating characters then we can increment the right pointer while the constraint is met.\\nIf the substring has repeating characters then we have two choices:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Either we keep incrementing the right pointer - but that doesn't make any sense because the string has repeated characters.\\nAny more addition in the string will only make it contain repeated characters\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Or we can increment the left pointer and hope to drop the repeating characters\")), mdx(\"p\", null, \"Since in this approach, all the elements will be traversed at most twice - once by each left and right pointer.\\nSo the time complexity will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n * (cost of finding repeating characters))\")), mdx(\"p\", null, \"I wouldn't have been able to solve this using two-pointer approach had I not watched the video from the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=eS6PZLjoaq8\"\n  }, \"Back to Back SWE\"), \".\"), mdx(\"p\", null, \"But the main problem still remains to be solved: How do I find if a string has repeating characters or not?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function hasRepeatingCharacters(s: string): boolean {\\n  const seenCharacters = new Set([...s]);\\n  return seenCharacters.size < s.length;\\n}\\n\\nfunction lengthOfLongestSubstring(s: string): number {\\n  let leftPointer = 0;\\n  let rightPointer = 1;\\n  let answer = 0;\\n\\n  while (rightPointer <= s.length) {\\n    const substringToCheck = s.substring(leftPointer, rightPointer);\\n    if (hasRepeatingCharacters(substringToCheck)) {\\n      leftPointer += 1;\\n      continue;\\n    }\\n    answer = Math.max(answer, substringToCheck.length);\\n    rightPointer += 1;\\n  }\\n\\n  return answer;\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Two Sum Problem Statement: Given an array of integers  nums  and an integer  target , return indices of the two numbers such that they addâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/blind-75","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}