{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/two-dimensional-dp",
    "result": {"data":{"post":{"slug":"/two-dimensional-dp","title":"Leetcode Two Dimensional DP problems","date":"19.05.2022","tags":[{"name":"DynamicProgramming","slug":"dynamic-programming"},{"name":"Algorithms","slug":"algorithms"},{"name":"Blind75","slug":"blind-75"},{"name":"LeetCode","slug":"leet-code"}],"description":"A blog meant to serve as breadcrumbs for my futureself consisting of thoughts, gotchas and the final solutions when going through the LeetCode problems in the Blind75 list around 2D DP.","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Leetcode Two Dimensional DP problems\",\n  \"slug\": \"two-dimensional-dp\",\n  \"date\": \"2022-05-19T00:00:00.000Z\",\n  \"updatedOn\": \"2022-05-19T00:00:00.000Z\",\n  \"description\": \"A blog meant to serve as breadcrumbs for my futureself consisting of thoughts, gotchas and the final solutions when going through the LeetCode problems in the Blind75 list around 2D DP.\",\n  \"tags\": [\"DynamicProgramming\", \"Algorithms\", \"Blind75\", \"LeetCode\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/unique-paths/\"\n  }, \"Unique Paths\")), mdx(\"h4\", null, \"Problem Statement:\"), mdx(\"p\", null, \"There is a robot on an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"m x n\"), \" grid.\\nThe robot is initially located at the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"top-left corner\"), \" (i.e., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"grid[0][0]\"), \").\\nThe robot tries to move to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"bottom-right corner\"), \" (i.e., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"grid[m - 1][n - 1]\"), \").\\nThe robot can only move either down or right at any point in time.\"), mdx(\"p\", null, \"Given the two integers \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"m\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \", return \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the number of possible unique paths that the robot can take to reach the bottom-right corner\"), \".\"), mdx(\"h4\", null, \"Solution:\"), mdx(\"h5\", null, \"Recursive Solution:\"), mdx(\"p\", null, \"Suppose we are at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j)\"), \"th cell in the grid and we want to count the number of unique paths that are possible from (i, j) to (m - 1, n - 1).\\nSince from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j)\"), \" we can only go down i.e., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i + 1, j)\"), \" or right i.e., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j + 1)\"), \", our problem at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j)\"), \" can be broken into two sub-problems:\\nfinding number of unique paths from the node below \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i + 1, j)\"), \" and finding the number of unique paths from the node to the right \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j + 1)\"), \".\\nIf we take a look at all the paths returned by these two neighbor nodes, the starting node of these two paths are different - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i + 1, j)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j - 1)\"), \".\\nHence, there won't be any common path among these two sub-problems.\\nTherefore, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(i, j)\"), \" is simply \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(i + 1, j) + countUniquePaths(i, j + 1)\"), \".\"), mdx(\"p\", null, \"The time complexity of this algorithm is since each node in the grid has at most two neighbours we are going to branch twice at each node.\\nAnd the depth of this branch will be at most \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"m + n\"), \" and hence the time complexity of this recursive solution is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(2 ^ (m + n))\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Optimizing overlapping subproblems:\")), mdx(\"p\", null, \"But there's actually a lot of overlapping sub-problems.\\nFor example: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(0, 0)\"), \" requires solving \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(1, 0)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(0, 1)\"), \".\\nIf we take a look at these two sub-problems:\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(1, 0)\"), \" requires solving \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(2, 0)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(1, 1)\"), \".\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(0, 1)\"), \" requires solving \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(1, 1)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(0, 2)\"), \".\\nSo by the time we come to solving \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(0, 1)\"), \" we would have already solved \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countUniquePaths(1, 1)\"), \" and we can re-use its result to avoid branching.\"), mdx(\"p\", null, \"So by introducing memoization, we will compute the results for each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j)\"), \" only once.\\nAlso, since we are only adding results of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i + 1, j)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j + 1)\"), \" at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j)\"), \", the cost of computing result at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j)\"), \" becomes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(1)\"), \".\"), mdx(\"p\", null, \"Hence the overall complexity after adding memoization becomes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(m * n)\"), \".\"), mdx(\"h5\", null, \"Iterative Solution:\"), mdx(\"p\", null, \"Let \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniquePaths[i][j]\"), \" denote the number of paths from the node \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i, j)\"), \" till \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(m - 1, n - 1)\"), \".\\nSince \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniquePaths[i][j] = uniquePaths[i + 1][j] + uniquePaths[i][j + 1]\"), \", we start filling the DP array from bottom to top and from right to left.\"), mdx(\"p\", null, \"The code for this approach can be found \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://leetcode.com/submissions/detail/702254050/\"\n  }, \"here\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Unique Paths Problem Statement: There is a robot on an  m x n  grid.\nThe robot is initially located at the  top-left corner  (i.e.,  grid[â€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/two-dimensional-dp","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}